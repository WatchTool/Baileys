diff --git a/src/curve.js b/src/curve.js
index 55b4b8090e0380599b90bf7808599acab7ff1479..a5dae9a67e261e550a8a1fe75a09898aa4c973db 100644
--- a/src/curve.js
+++ b/src/curve.js
@@ -1,15 +1,14 @@
+"use strict";
 
-'use strict';
-
-const curveJs = require('curve25519-js');
-const nodeCrypto = require('crypto');
+const curveJs = require("curve25519-js");
+const nodeCrypto = require("crypto");
 // from: https://github.com/digitalbazaar/x25519-key-agreement-key-2019/blob/master/lib/crypto.js
 const PUBLIC_KEY_DER_PREFIX = Buffer.from([
-    48, 42, 48, 5, 6, 3, 43, 101, 110, 3, 33, 0
+  48, 42, 48, 5, 6, 3, 43, 101, 110, 3, 33, 0,
 ]);
-  
+
 const PRIVATE_KEY_DER_PREFIX = Buffer.from([
-    48, 46, 2, 1, 0, 48, 5, 6, 3, 43, 101, 110, 4, 34, 4, 32
+  48, 46, 2, 1, 0, 48, 5, 6, 3, 43, 101, 110, 4, 34, 4, 32,
 ]);
 
 const KEY_BUNDLE_TYPE = Buffer.from([5]);
@@ -19,124 +18,130 @@ const prefixKeyInPublicKey = function (pubKey) {
 };
 
 function validatePrivKey(privKey) {
-    if (privKey === undefined) {
-        throw new Error("Undefined private key");
-    }
-    if (!(privKey instanceof Buffer)) {
-        throw new Error(`Invalid private key type: ${privKey.constructor.name}`);
-    }
-    if (privKey.byteLength != 32) {
-        throw new Error(`Incorrect private key length: ${privKey.byteLength}`);
-    }
+  if (privKey === undefined) {
+    throw new Error("Undefined private key");
+  }
+  if (!(privKey instanceof Buffer)) {
+    throw new Error(`Invalid private key type: ${privKey.constructor.name}`);
+  }
+  if (privKey.byteLength != 32) {
+    throw new Error(`Incorrect private key length: ${privKey.byteLength}`);
+  }
 }
 
 function scrubPubKeyFormat(pubKey) {
-    if (!(pubKey instanceof Buffer)) {
-        throw new Error(`Invalid public key type: ${pubKey.constructor.name}`);
-    }
-    if (pubKey === undefined || ((pubKey.byteLength != 33 || pubKey[0] != 5) && pubKey.byteLength != 32)) {
-        throw new Error("Invalid public key");
-    }
-    if (pubKey.byteLength == 33) {
-        return pubKey.slice(1);
-    } else {
-        console.error("WARNING: Expected pubkey of length 33, please report the ST and client that generated the pubkey");
-        return pubKey;
-    }
+  if (!(pubKey instanceof Buffer)) {
+    throw new Error(`Invalid public key type: ${pubKey.constructor.name}`);
+  }
+  if (
+    pubKey === undefined ||
+    ((pubKey.byteLength != 33 || pubKey[0] != 5) && pubKey.byteLength != 32)
+  ) {
+    throw new Error("Invalid public key");
+  }
+  if (pubKey.byteLength == 33) {
+    return pubKey.slice(1);
+  } else {
+    return pubKey;
+  }
 }
 
 function unclampEd25519PrivateKey(clampedSk) {
-    const unclampedSk = new Uint8Array(clampedSk);
+  const unclampedSk = new Uint8Array(clampedSk);
 
-    // Fix the first byte
-    unclampedSk[0] |= 6; // Ensure last 3 bits match expected `110` pattern
+  // Fix the first byte
+  unclampedSk[0] |= 6; // Ensure last 3 bits match expected `110` pattern
 
-    // Fix the last byte
-    unclampedSk[31] |= 128; // Restore the highest bit
-    unclampedSk[31] &= ~64; // Clear the second-highest bit
+  // Fix the last byte
+  unclampedSk[31] |= 128; // Restore the highest bit
+  unclampedSk[31] &= ~64; // Clear the second-highest bit
 
-    return unclampedSk;
+  return unclampedSk;
 }
 
-exports.getPublicFromPrivateKey = function(privKey) {
-    const unclampedPK = unclampEd25519PrivateKey(privKey);
-    const keyPair = curveJs.generateKeyPair(unclampedPK);
-    return prefixKeyInPublicKey(Buffer.from(keyPair.public));
+exports.getPublicFromPrivateKey = function (privKey) {
+  const unclampedPK = unclampEd25519PrivateKey(privKey);
+  const keyPair = curveJs.generateKeyPair(unclampedPK);
+  return prefixKeyInPublicKey(Buffer.from(keyPair.public));
 };
 
-exports.generateKeyPair = function() {
-    try {
-        const {publicKey: publicDerBytes, privateKey: privateDerBytes} = nodeCrypto.generateKeyPairSync(
-            'x25519',
-            {
-                publicKeyEncoding: { format: 'der', type: 'spki' },
-                privateKeyEncoding: { format: 'der', type: 'pkcs8' }
-            }
-        );
-        const pubKey = publicDerBytes.slice(PUBLIC_KEY_DER_PREFIX.length, PUBLIC_KEY_DER_PREFIX.length + 32);
-    
-        const privKey = privateDerBytes.slice(PRIVATE_KEY_DER_PREFIX.length, PRIVATE_KEY_DER_PREFIX.length + 32);
-    
-        return {
-            pubKey: prefixKeyInPublicKey(pubKey),
-            privKey
-        };
-    } catch(e) {
-        const keyPair = curveJs.generateKeyPair(nodeCrypto.randomBytes(32));
-        return {
-            privKey: Buffer.from(keyPair.private),
-            pubKey: prefixKeyInPublicKey(Buffer.from(keyPair.public)),
-        };
-    }
+exports.generateKeyPair = function () {
+  try {
+    const { publicKey: publicDerBytes, privateKey: privateDerBytes } =
+      nodeCrypto.generateKeyPairSync("x25519", {
+        publicKeyEncoding: { format: "der", type: "spki" },
+        privateKeyEncoding: { format: "der", type: "pkcs8" },
+      });
+    const pubKey = publicDerBytes.slice(
+      PUBLIC_KEY_DER_PREFIX.length,
+      PUBLIC_KEY_DER_PREFIX.length + 32
+    );
+
+    const privKey = privateDerBytes.slice(
+      PRIVATE_KEY_DER_PREFIX.length,
+      PRIVATE_KEY_DER_PREFIX.length + 32
+    );
+
+    return {
+      pubKey: prefixKeyInPublicKey(pubKey),
+      privKey,
+    };
+  } catch (e) {
+    const keyPair = curveJs.generateKeyPair(nodeCrypto.randomBytes(32));
+    return {
+      privKey: Buffer.from(keyPair.private),
+      pubKey: prefixKeyInPublicKey(Buffer.from(keyPair.public)),
+    };
+  }
 };
 
-exports.calculateAgreement = function(pubKey, privKey) {
-    pubKey = scrubPubKeyFormat(pubKey);
-    validatePrivKey(privKey);
-    if (!pubKey || pubKey.byteLength != 32) {
-        throw new Error("Invalid public key");
-    }
-
-    if(typeof nodeCrypto.diffieHellman === 'function') {
-        const nodePrivateKey = nodeCrypto.createPrivateKey({
-            key: Buffer.concat([PRIVATE_KEY_DER_PREFIX, privKey]),
-            format: 'der',
-            type: 'pkcs8'
-        });
-        const nodePublicKey = nodeCrypto.createPublicKey({
-            key: Buffer.concat([PUBLIC_KEY_DER_PREFIX, pubKey]),
-            format: 'der',
-            type: 'spki'
-        });
-        
-        return nodeCrypto.diffieHellman({
-            privateKey: nodePrivateKey,
-            publicKey: nodePublicKey,
-        });
-    } else {
-        const secret = curveJs.sharedKey(privKey, pubKey);
-        return Buffer.from(secret);
-    }
+exports.calculateAgreement = function (pubKey, privKey) {
+  pubKey = scrubPubKeyFormat(pubKey);
+  validatePrivKey(privKey);
+  if (!pubKey || pubKey.byteLength != 32) {
+    throw new Error("Invalid public key");
+  }
+
+  if (typeof nodeCrypto.diffieHellman === "function") {
+    const nodePrivateKey = nodeCrypto.createPrivateKey({
+      key: Buffer.concat([PRIVATE_KEY_DER_PREFIX, privKey]),
+      format: "der",
+      type: "pkcs8",
+    });
+    const nodePublicKey = nodeCrypto.createPublicKey({
+      key: Buffer.concat([PUBLIC_KEY_DER_PREFIX, pubKey]),
+      format: "der",
+      type: "spki",
+    });
+
+    return nodeCrypto.diffieHellman({
+      privateKey: nodePrivateKey,
+      publicKey: nodePublicKey,
+    });
+  } else {
+    const secret = curveJs.sharedKey(privKey, pubKey);
+    return Buffer.from(secret);
+  }
 };
 
-exports.calculateSignature = function(privKey, message) {
-    validatePrivKey(privKey);
-    if (!message) {
-        throw new Error("Invalid message");
-    }
-    return Buffer.from(curveJs.sign(privKey, message));
+exports.calculateSignature = function (privKey, message) {
+  validatePrivKey(privKey);
+  if (!message) {
+    throw new Error("Invalid message");
+  }
+  return Buffer.from(curveJs.sign(privKey, message));
 };
 
-exports.verifySignature = function(pubKey, msg, sig, isInit) {
-    pubKey = scrubPubKeyFormat(pubKey);
-    if (!pubKey || pubKey.byteLength != 32) {
-        throw new Error("Invalid public key");
-    }
-    if (!msg) {
-        throw new Error("Invalid message");
-    }
-    if (!sig || sig.byteLength != 64) {
-        throw new Error("Invalid signature");
-    }
-    return isInit ? true : curveJs.verify(pubKey, msg, sig);
+exports.verifySignature = function (pubKey, msg, sig, isInit) {
+  pubKey = scrubPubKeyFormat(pubKey);
+  if (!pubKey || pubKey.byteLength != 32) {
+    throw new Error("Invalid public key");
+  }
+  if (!msg) {
+    throw new Error("Invalid message");
+  }
+  if (!sig || sig.byteLength != 64) {
+    throw new Error("Invalid signature");
+  }
+  return isInit ? true : curveJs.verify(pubKey, msg, sig);
 };
diff --git a/src/queue_job.js b/src/queue_job.js
index baab89c48e66d4c3fb704abd35c1cfff979bb518..b2f76e2a523d7c70208d6d3c780e312fbf07c533 100644
--- a/src/queue_job.js
+++ b/src/queue_job.js
@@ -1,69 +1,69 @@
 // vim: ts=4:sw=4:expandtab
- 
- /*
-  * jobQueue manages multiple queues indexed by device to serialize
-  * session io ops on the database.
-  */
-'use strict';
 
+/*
+ * jobQueue manages multiple queues indexed by device to serialize
+ * session io ops on the database.
+ */
+"use strict";
 
 const _queueAsyncBuckets = new Map();
 const _gcLimit = 10000;
 
 async function _asyncQueueExecutor(queue, cleanup) {
-    let offt = 0;
-    while (true) {
-        let limit = Math.min(queue.length, _gcLimit); // Break up thundering hurds for GC duty.
-        for (let i = offt; i < limit; i++) {
-            const job = queue[i];
-            try {
-                job.resolve(await job.awaitable());
-            } catch(e) {
-                job.reject(e);
-            }
-        }
-        if (limit < queue.length) {
-            /* Perform lazy GC of queue for faster iteration. */
-            if (limit >= _gcLimit) {
-                queue.splice(0, limit);
-                offt = 0;
-            } else {
-                offt = limit;
-            }
-        } else {
-            break;
-        }
+  let offt = 0;
+  while (true) {
+    let limit = Math.min(queue.length, _gcLimit); // Break up thundering hurds for GC duty.
+    for (let i = offt; i < limit; i++) {
+      const job = queue[i];
+      try {
+        job.resolve(await job.awaitable());
+      } catch (e) {
+        job.reject(e);
+      }
     }
-    cleanup();
+    if (limit < queue.length) {
+      /* Perform lazy GC of queue for faster iteration. */
+      if (limit >= _gcLimit) {
+        queue.splice(0, limit);
+        offt = 0;
+      } else {
+        offt = limit;
+      }
+    } else {
+      break;
+    }
+  }
+  cleanup();
 }
 
-module.exports = function(bucket, awaitable) {
-    /* Run the async awaitable only when all other async calls registered
-     * here have completed (or thrown).  The bucket argument is a hashable
-     * key representing the task queue to use. */
-    if (!awaitable.name) {
-        // Make debuging easier by adding a name to this function.
-        Object.defineProperty(awaitable, 'name', {writable: true});
-        if (typeof bucket === 'string') {
-            awaitable.name = bucket;
-        } else {
-            console.warn("Unhandled bucket type (for naming):", typeof bucket, bucket);
-        }
-    }
-    let inactive;
-    if (!_queueAsyncBuckets.has(bucket)) {
-        _queueAsyncBuckets.set(bucket, []);
-        inactive = true;
-    }
-    const queue = _queueAsyncBuckets.get(bucket);
-    const job = new Promise((resolve, reject) => queue.push({
-        awaitable,
-        resolve,
-        reject
-    }));
-    if (inactive) {
-        /* An executor is not currently active; Start one now. */
-        _asyncQueueExecutor(queue, () => _queueAsyncBuckets.delete(bucket));
+module.exports = function (bucket, awaitable) {
+  /* Run the async awaitable only when all other async calls registered
+   * here have completed (or thrown).  The bucket argument is a hashable
+   * key representing the task queue to use. */
+  if (!awaitable.name) {
+    // Make debuging easier by adding a name to this function.
+    Object.defineProperty(awaitable, "name", { writable: true });
+    if (typeof bucket === "string") {
+      awaitable.name = bucket;
+    } else {
     }
-    return job;
+  }
+  let inactive;
+  if (!_queueAsyncBuckets.has(bucket)) {
+    _queueAsyncBuckets.set(bucket, []);
+    inactive = true;
+  }
+  const queue = _queueAsyncBuckets.get(bucket);
+  const job = new Promise((resolve, reject) =>
+    queue.push({
+      awaitable,
+      resolve,
+      reject,
+    })
+  );
+  if (inactive) {
+    /* An executor is not currently active; Start one now. */
+    _asyncQueueExecutor(queue, () => _queueAsyncBuckets.delete(bucket));
+  }
+  return job;
 };
diff --git a/src/session_builder.js b/src/session_builder.js
index 7b7d8520fe660c91769f8cc26d69b95d718a222c..380555b31e5b242ddede4871792b1b3a512a9610 100644
--- a/src/session_builder.js
+++ b/src/session_builder.js
@@ -1,164 +1,219 @@
+"use strict";
 
-'use strict';
-
-const BaseKeyType = require('./base_key_type');
-const ChainType = require('./chain_type');
-const SessionRecord = require('./session_record');
-const crypto = require('./crypto');
-const curve = require('./curve');
-const errors = require('./errors');
-const queueJob = require('./queue_job');
-
+const BaseKeyType = require("./base_key_type");
+const ChainType = require("./chain_type");
+const SessionRecord = require("./session_record");
+const crypto = require("./crypto");
+const curve = require("./curve");
+const errors = require("./errors");
+const queueJob = require("./queue_job");
 
 class SessionBuilder {
+  constructor(storage, protocolAddress) {
+    this.addr = protocolAddress;
+    this.storage = storage;
+  }
 
-    constructor(storage, protocolAddress) {
-        this.addr = protocolAddress;
-        this.storage = storage;
-    }
+  async initOutgoing(device) {
+    const fqAddr = this.addr.toString();
+    return await queueJob(fqAddr, async () => {
+      if (
+        !(await this.storage.isTrustedIdentity(
+          this.addr.id,
+          device.identityKey
+        ))
+      ) {
+        throw new errors.UntrustedIdentityKeyError(
+          this.addr.id,
+          device.identityKey
+        );
+      }
+      curve.verifySignature(
+        device.identityKey,
+        device.signedPreKey.publicKey,
+        device.signedPreKey.signature,
+        true
+      );
+      const baseKey = curve.generateKeyPair();
+      const devicePreKey = device.preKey && device.preKey.publicKey;
+      const session = await this.initSession(
+        true,
+        baseKey,
+        undefined,
+        device.identityKey,
+        devicePreKey,
+        device.signedPreKey.publicKey,
+        device.registrationId
+      );
+      session.pendingPreKey = {
+        signedKeyId: device.signedPreKey.keyId,
+        baseKey: baseKey.pubKey,
+      };
+      if (device.preKey) {
+        session.pendingPreKey.preKeyId = device.preKey.keyId;
+      }
+      let record = await this.storage.loadSession(fqAddr);
+      if (!record) {
+        record = new SessionRecord();
+      } else {
+        const openSession = record.getOpenSession();
+        if (openSession) {
+          record.closeSession(openSession);
+        }
+      }
+      record.setSession(session);
+      await this.storage.storeSession(fqAddr, record);
+    });
+  }
 
-    async initOutgoing(device) {
-        const fqAddr = this.addr.toString();
-        return await queueJob(fqAddr, async () => {
-            if (!await this.storage.isTrustedIdentity(this.addr.id, device.identityKey)) {
-                throw new errors.UntrustedIdentityKeyError(this.addr.id, device.identityKey);
-            }
-            curve.verifySignature(device.identityKey, device.signedPreKey.publicKey,
-                                  device.signedPreKey.signature, true);
-            const baseKey = curve.generateKeyPair();
-            const devicePreKey = device.preKey && device.preKey.publicKey;
-            const session = await this.initSession(true, baseKey, undefined, device.identityKey,
-                                                   devicePreKey, device.signedPreKey.publicKey,
-                                                   device.registrationId);
-            session.pendingPreKey = {
-                signedKeyId: device.signedPreKey.keyId,
-                baseKey: baseKey.pubKey
-            };
-            if (device.preKey) {
-                session.pendingPreKey.preKeyId = device.preKey.keyId;
-            }
-            let record = await this.storage.loadSession(fqAddr);
-            if (!record) {
-                record = new SessionRecord();
-            } else {
-                const openSession = record.getOpenSession();
-                if (openSession) {
-                    console.warn("Closing stale open session for new outgoing prekey bundle");
-                    record.closeSession(openSession);
-                }
-            }
-            record.setSession(session);
-            await this.storage.storeSession(fqAddr, record);
-        });
+  async initIncoming(record, message) {
+    const fqAddr = this.addr.toString();
+    if (!(await this.storage.isTrustedIdentity(fqAddr, message.identityKey))) {
+      throw new errors.UntrustedIdentityKeyError(
+        this.addr.id,
+        message.identityKey
+      );
     }
-
-    async initIncoming(record, message) {
-        const fqAddr = this.addr.toString();
-        if (!await this.storage.isTrustedIdentity(fqAddr, message.identityKey)) {
-            throw new errors.UntrustedIdentityKeyError(this.addr.id, message.identityKey);
-        }
-        if (record.getSession(message.baseKey)) {
-            // This just means we haven't replied.
-            return;
-        }
-        const preKeyPair = await this.storage.loadPreKey(message.preKeyId);
-        if (message.preKeyId && !preKeyPair) {
-            throw new errors.PreKeyError('Invalid PreKey ID');
-        }   
-        const signedPreKeyPair = await this.storage.loadSignedPreKey(message.signedPreKeyId);
-        if (!signedPreKeyPair) { 
-            throw new errors.PreKeyError("Missing SignedPreKey");
-        }   
-        const existingOpenSession = record.getOpenSession();
-        if (existingOpenSession) {
-            console.warn("Closing open session in favor of incoming prekey bundle");
-            record.closeSession(existingOpenSession);
-        }
-        record.setSession(await this.initSession(false, preKeyPair, signedPreKeyPair,
-                                                 message.identityKey, message.baseKey,
-                                                 undefined, message.registrationId));
-        return message.preKeyId;
+    if (record.getSession(message.baseKey)) {
+      // This just means we haven't replied.
+      return;
     }
-
-    async initSession(isInitiator, ourEphemeralKey, ourSignedKey, theirIdentityPubKey,
-                      theirEphemeralPubKey, theirSignedPubKey, registrationId) {
-        if (isInitiator) {
-            if (ourSignedKey) {
-                throw new Error("Invalid call to initSession");
-            }
-            ourSignedKey = ourEphemeralKey;
-        } else {
-            if (theirSignedPubKey) {
-                throw new Error("Invalid call to initSession");
-            }
-            theirSignedPubKey = theirEphemeralPubKey;
-        }
-        let sharedSecret;
-        if (!ourEphemeralKey || !theirEphemeralPubKey) {
-            sharedSecret = new Uint8Array(32 * 4);
-        } else {
-            sharedSecret = new Uint8Array(32 * 5);
-        }
-        for (var i = 0; i < 32; i++) {
-            sharedSecret[i] = 0xff;
-        }
-        const ourIdentityKey = await this.storage.getOurIdentity();
-        const a1 = curve.calculateAgreement(theirSignedPubKey, ourIdentityKey.privKey);
-        const a2 = curve.calculateAgreement(theirIdentityPubKey, ourSignedKey.privKey);
-        const a3 = curve.calculateAgreement(theirSignedPubKey, ourSignedKey.privKey);
-        if (isInitiator) {
-            sharedSecret.set(new Uint8Array(a1), 32);
-            sharedSecret.set(new Uint8Array(a2), 32 * 2);
-        } else {
-            sharedSecret.set(new Uint8Array(a1), 32 * 2);
-            sharedSecret.set(new Uint8Array(a2), 32);
-        }
-        sharedSecret.set(new Uint8Array(a3), 32 * 3);
-        if (ourEphemeralKey && theirEphemeralPubKey) {
-            const a4 = curve.calculateAgreement(theirEphemeralPubKey, ourEphemeralKey.privKey);
-            sharedSecret.set(new Uint8Array(a4), 32 * 4);
-        }
-        const masterKey = crypto.deriveSecrets(Buffer.from(sharedSecret), Buffer.alloc(32),
-                                               Buffer.from("WhisperText"));
-        const session = SessionRecord.createEntry();
-        session.registrationId = registrationId;
-        session.currentRatchet = {
-            rootKey: masterKey[0],
-            ephemeralKeyPair: isInitiator ? curve.generateKeyPair() : ourSignedKey,
-            lastRemoteEphemeralKey: theirSignedPubKey,
-            previousCounter: 0
-        };
-        session.indexInfo = {
-            created: Date.now(),
-            used: Date.now(),
-            remoteIdentityKey: theirIdentityPubKey,
-            baseKey: isInitiator ? ourEphemeralKey.pubKey : theirEphemeralPubKey,
-            baseKeyType: isInitiator ? BaseKeyType.OURS : BaseKeyType.THEIRS,
-            closed: -1
-        };
-        if (isInitiator) {
-            // If we're initiating we go ahead and set our first sending ephemeral key now,
-            // otherwise we figure it out when we first maybeStepRatchet with the remote's
-            // ephemeral key
-            this.calculateSendingRatchet(session, theirSignedPubKey);
-        }
-        return session;
+    const preKeyPair = await this.storage.loadPreKey(message.preKeyId);
+    if (message.preKeyId && !preKeyPair) {
+      throw new errors.PreKeyError("Invalid PreKey ID");
     }
+    const signedPreKeyPair = await this.storage.loadSignedPreKey(
+      message.signedPreKeyId
+    );
+    if (!signedPreKeyPair) {
+      throw new errors.PreKeyError("Missing SignedPreKey");
+    }
+    const existingOpenSession = record.getOpenSession();
+    if (existingOpenSession) {
+      record.closeSession(existingOpenSession);
+    }
+    record.setSession(
+      await this.initSession(
+        false,
+        preKeyPair,
+        signedPreKeyPair,
+        message.identityKey,
+        message.baseKey,
+        undefined,
+        message.registrationId
+      )
+    );
+    return message.preKeyId;
+  }
 
-    calculateSendingRatchet(session, remoteKey) {
-        const ratchet = session.currentRatchet;
-        const sharedSecret = curve.calculateAgreement(remoteKey, ratchet.ephemeralKeyPair.privKey);
-        const masterKey = crypto.deriveSecrets(sharedSecret, ratchet.rootKey, Buffer.from("WhisperRatchet"));
-        session.addChain(ratchet.ephemeralKeyPair.pubKey, {
-            messageKeys: {},
-            chainKey: {
-                counter: -1,
-                key: masterKey[1]
-            },
-            chainType: ChainType.SENDING
-        });
-        ratchet.rootKey = masterKey[0];
+  async initSession(
+    isInitiator,
+    ourEphemeralKey,
+    ourSignedKey,
+    theirIdentityPubKey,
+    theirEphemeralPubKey,
+    theirSignedPubKey,
+    registrationId
+  ) {
+    if (isInitiator) {
+      if (ourSignedKey) {
+        throw new Error("Invalid call to initSession");
+      }
+      ourSignedKey = ourEphemeralKey;
+    } else {
+      if (theirSignedPubKey) {
+        throw new Error("Invalid call to initSession");
+      }
+      theirSignedPubKey = theirEphemeralPubKey;
+    }
+    let sharedSecret;
+    if (!ourEphemeralKey || !theirEphemeralPubKey) {
+      sharedSecret = new Uint8Array(32 * 4);
+    } else {
+      sharedSecret = new Uint8Array(32 * 5);
     }
+    for (var i = 0; i < 32; i++) {
+      sharedSecret[i] = 0xff;
+    }
+    const ourIdentityKey = await this.storage.getOurIdentity();
+    const a1 = curve.calculateAgreement(
+      theirSignedPubKey,
+      ourIdentityKey.privKey
+    );
+    const a2 = curve.calculateAgreement(
+      theirIdentityPubKey,
+      ourSignedKey.privKey
+    );
+    const a3 = curve.calculateAgreement(
+      theirSignedPubKey,
+      ourSignedKey.privKey
+    );
+    if (isInitiator) {
+      sharedSecret.set(new Uint8Array(a1), 32);
+      sharedSecret.set(new Uint8Array(a2), 32 * 2);
+    } else {
+      sharedSecret.set(new Uint8Array(a1), 32 * 2);
+      sharedSecret.set(new Uint8Array(a2), 32);
+    }
+    sharedSecret.set(new Uint8Array(a3), 32 * 3);
+    if (ourEphemeralKey && theirEphemeralPubKey) {
+      const a4 = curve.calculateAgreement(
+        theirEphemeralPubKey,
+        ourEphemeralKey.privKey
+      );
+      sharedSecret.set(new Uint8Array(a4), 32 * 4);
+    }
+    const masterKey = crypto.deriveSecrets(
+      Buffer.from(sharedSecret),
+      Buffer.alloc(32),
+      Buffer.from("WhisperText")
+    );
+    const session = SessionRecord.createEntry();
+    session.registrationId = registrationId;
+    session.currentRatchet = {
+      rootKey: masterKey[0],
+      ephemeralKeyPair: isInitiator ? curve.generateKeyPair() : ourSignedKey,
+      lastRemoteEphemeralKey: theirSignedPubKey,
+      previousCounter: 0,
+    };
+    session.indexInfo = {
+      created: Date.now(),
+      used: Date.now(),
+      remoteIdentityKey: theirIdentityPubKey,
+      baseKey: isInitiator ? ourEphemeralKey.pubKey : theirEphemeralPubKey,
+      baseKeyType: isInitiator ? BaseKeyType.OURS : BaseKeyType.THEIRS,
+      closed: -1,
+    };
+    if (isInitiator) {
+      // If we're initiating we go ahead and set our first sending ephemeral key now,
+      // otherwise we figure it out when we first maybeStepRatchet with the remote's
+      // ephemeral key
+      this.calculateSendingRatchet(session, theirSignedPubKey);
+    }
+    return session;
+  }
+
+  calculateSendingRatchet(session, remoteKey) {
+    const ratchet = session.currentRatchet;
+    const sharedSecret = curve.calculateAgreement(
+      remoteKey,
+      ratchet.ephemeralKeyPair.privKey
+    );
+    const masterKey = crypto.deriveSecrets(
+      sharedSecret,
+      ratchet.rootKey,
+      Buffer.from("WhisperRatchet")
+    );
+    session.addChain(ratchet.ephemeralKeyPair.pubKey, {
+      messageKeys: {},
+      chainKey: {
+        counter: -1,
+        key: masterKey[1],
+      },
+      chainType: ChainType.SENDING,
+    });
+    ratchet.rootKey = masterKey[0];
+  }
 }
 
 module.exports = SessionBuilder;
diff --git a/src/session_cipher.js b/src/session_cipher.js
index 0e6df11ee52cf6de3403a0c6f38254c674690312..9b946720443cea9dd96f24b28894802b666816bb 100644
--- a/src/session_cipher.js
+++ b/src/session_cipher.js
@@ -1,336 +1,370 @@
 // vim: ts=4:sw=4:expandtab
 
-const ChainType = require('./chain_type');
-const ProtocolAddress = require('./protocol_address');
-const SessionBuilder = require('./session_builder');
-const SessionRecord = require('./session_record');
-const crypto = require('./crypto');
-const curve = require('./curve');
-const errors = require('./errors');
-const protobufs = require('./protobufs');
-const queueJob = require('./queue_job');
+const ChainType = require("./chain_type");
+const ProtocolAddress = require("./protocol_address");
+const SessionBuilder = require("./session_builder");
+const SessionRecord = require("./session_record");
+const crypto = require("./crypto");
+const curve = require("./curve");
+const errors = require("./errors");
+const protobufs = require("./protobufs");
+const queueJob = require("./queue_job");
 
 const VERSION = 3;
 
 function assertBuffer(value) {
-    if (!(value instanceof Buffer)) {
-        throw TypeError(`Expected Buffer instead of: ${value.constructor.name}`);
-    }
-    return value;
+  if (!(value instanceof Buffer)) {
+    throw TypeError(`Expected Buffer instead of: ${value.constructor.name}`);
+  }
+  return value;
 }
 
-
 class SessionCipher {
-
-    constructor(storage, protocolAddress) {
-        if (!(protocolAddress instanceof ProtocolAddress)) {
-            throw new TypeError("protocolAddress must be a ProtocolAddress");
-        }
-        this.addr = protocolAddress;
-        this.storage = storage;
+  constructor(storage, protocolAddress) {
+    if (!(protocolAddress instanceof ProtocolAddress)) {
+      throw new TypeError("protocolAddress must be a ProtocolAddress");
     }
+    this.addr = protocolAddress;
+    this.storage = storage;
+  }
 
-    _encodeTupleByte(number1, number2) {
-        if (number1 > 15 || number2 > 15) {
-            throw TypeError("Numbers must be 4 bits or less");
-        }
-        return (number1 << 4) | number2;
+  _encodeTupleByte(number1, number2) {
+    if (number1 > 15 || number2 > 15) {
+      throw TypeError("Numbers must be 4 bits or less");
     }
+    return (number1 << 4) | number2;
+  }
 
-    _decodeTupleByte(byte) {
-        return [byte >> 4, byte & 0xf];
-    }
+  _decodeTupleByte(byte) {
+    return [byte >> 4, byte & 0xf];
+  }
 
-    toString() {
-        return `<SessionCipher(${this.addr.toString()})>`;
-    }
+  toString() {
+    return `<SessionCipher(${this.addr.toString()})>`;
+  }
 
-    async getRecord() {
-        const record = await this.storage.loadSession(this.addr.toString());
-        if (record && !(record instanceof SessionRecord)) {
-            throw new TypeError('SessionRecord type expected from loadSession'); 
-        }
-        return record;
+  async getRecord() {
+    const record = await this.storage.loadSession(this.addr.toString());
+    if (record && !(record instanceof SessionRecord)) {
+      throw new TypeError("SessionRecord type expected from loadSession");
     }
+    return record;
+  }
 
-    async storeRecord(record) {
-        record.removeOldSessions();
-        await this.storage.storeSession(this.addr.toString(), record);
-    }
+  async storeRecord(record) {
+    record.removeOldSessions();
+    await this.storage.storeSession(this.addr.toString(), record);
+  }
 
-    async queueJob(awaitable) {
-        return await queueJob(this.addr.toString(), awaitable);
-    }
+  async queueJob(awaitable) {
+    return await queueJob(this.addr.toString(), awaitable);
+  }
 
-    async encrypt(data) {
-        assertBuffer(data);
-        const ourIdentityKey = await this.storage.getOurIdentity();
-        return await this.queueJob(async () => {
-            const record = await this.getRecord();
-            if (!record) {
-                throw new errors.SessionError("No sessions");
-            }
-            const session = record.getOpenSession();
-            if (!session) {
-                throw new errors.SessionError("No open session");
-            }
-            const remoteIdentityKey = session.indexInfo.remoteIdentityKey;
-            if (!await this.storage.isTrustedIdentity(this.addr.id, remoteIdentityKey)) {
-                throw new errors.UntrustedIdentityKeyError(this.addr.id, remoteIdentityKey);
-            }
-            const chain = session.getChain(session.currentRatchet.ephemeralKeyPair.pubKey);
-            if (chain.chainType === ChainType.RECEIVING) {
-                throw new Error("Tried to encrypt on a receiving chain");
-            }
-            this.fillMessageKeys(chain, chain.chainKey.counter + 1);
-            const keys = crypto.deriveSecrets(chain.messageKeys[chain.chainKey.counter],
-                                              Buffer.alloc(32), Buffer.from("WhisperMessageKeys"));
-            delete chain.messageKeys[chain.chainKey.counter];
-            const msg = protobufs.WhisperMessage.create();
-            msg.ephemeralKey = session.currentRatchet.ephemeralKeyPair.pubKey;
-            msg.counter = chain.chainKey.counter;
-            msg.previousCounter = session.currentRatchet.previousCounter;
-            msg.ciphertext = crypto.encrypt(keys[0], data, keys[2].slice(0, 16));
-            const msgBuf = protobufs.WhisperMessage.encode(msg).finish();
-            const macInput = Buffer.alloc(msgBuf.byteLength + (33 * 2) + 1);
-            macInput.set(ourIdentityKey.pubKey);
-            macInput.set(session.indexInfo.remoteIdentityKey, 33);
-            macInput[33 * 2] = this._encodeTupleByte(VERSION, VERSION);
-            macInput.set(msgBuf, (33 * 2) + 1);
-            const mac = crypto.calculateMAC(keys[1], macInput);
-            const result = Buffer.alloc(msgBuf.byteLength + 9);
-            result[0] = this._encodeTupleByte(VERSION, VERSION);
-            result.set(msgBuf, 1);
-            result.set(mac.slice(0, 8), msgBuf.byteLength + 1);
-            await this.storeRecord(record);
-            let type, body;
-            if (session.pendingPreKey) {
-                type = 3;  // prekey bundle
-                const preKeyMsg = protobufs.PreKeyWhisperMessage.create({
-                    identityKey: ourIdentityKey.pubKey,
-                    registrationId: await this.storage.getOurRegistrationId(),
-                    baseKey: session.pendingPreKey.baseKey,
-                    signedPreKeyId: session.pendingPreKey.signedKeyId,
-                    message: result
-                });
-                if (session.pendingPreKey.preKeyId) {
-                    preKeyMsg.preKeyId = session.pendingPreKey.preKeyId;
-                }
-                body = Buffer.concat([
-                    Buffer.from([this._encodeTupleByte(VERSION, VERSION)]),
-                    Buffer.from(
-                        protobufs.PreKeyWhisperMessage.encode(preKeyMsg).finish()
-                    )
-                ]);
-            } else {
-                type = 1;  // normal
-                body = result;
-            }
-            return {
-                type,
-                body,
-                registrationId: session.registrationId
-            };
+  async encrypt(data) {
+    assertBuffer(data);
+    const ourIdentityKey = await this.storage.getOurIdentity();
+    return await this.queueJob(async () => {
+      const record = await this.getRecord();
+      if (!record) {
+        throw new errors.SessionError("No sessions");
+      }
+      const session = record.getOpenSession();
+      if (!session) {
+        throw new errors.SessionError("No open session");
+      }
+      const remoteIdentityKey = session.indexInfo.remoteIdentityKey;
+      if (
+        !(await this.storage.isTrustedIdentity(this.addr.id, remoteIdentityKey))
+      ) {
+        throw new errors.UntrustedIdentityKeyError(
+          this.addr.id,
+          remoteIdentityKey
+        );
+      }
+      const chain = session.getChain(
+        session.currentRatchet.ephemeralKeyPair.pubKey
+      );
+      if (chain.chainType === ChainType.RECEIVING) {
+        throw new Error("Tried to encrypt on a receiving chain");
+      }
+      this.fillMessageKeys(chain, chain.chainKey.counter + 1);
+      const keys = crypto.deriveSecrets(
+        chain.messageKeys[chain.chainKey.counter],
+        Buffer.alloc(32),
+        Buffer.from("WhisperMessageKeys")
+      );
+      delete chain.messageKeys[chain.chainKey.counter];
+      const msg = protobufs.WhisperMessage.create();
+      msg.ephemeralKey = session.currentRatchet.ephemeralKeyPair.pubKey;
+      msg.counter = chain.chainKey.counter;
+      msg.previousCounter = session.currentRatchet.previousCounter;
+      msg.ciphertext = crypto.encrypt(keys[0], data, keys[2].slice(0, 16));
+      const msgBuf = protobufs.WhisperMessage.encode(msg).finish();
+      const macInput = Buffer.alloc(msgBuf.byteLength + 33 * 2 + 1);
+      macInput.set(ourIdentityKey.pubKey);
+      macInput.set(session.indexInfo.remoteIdentityKey, 33);
+      macInput[33 * 2] = this._encodeTupleByte(VERSION, VERSION);
+      macInput.set(msgBuf, 33 * 2 + 1);
+      const mac = crypto.calculateMAC(keys[1], macInput);
+      const result = Buffer.alloc(msgBuf.byteLength + 9);
+      result[0] = this._encodeTupleByte(VERSION, VERSION);
+      result.set(msgBuf, 1);
+      result.set(mac.slice(0, 8), msgBuf.byteLength + 1);
+      await this.storeRecord(record);
+      let type, body;
+      if (session.pendingPreKey) {
+        type = 3; // prekey bundle
+        const preKeyMsg = protobufs.PreKeyWhisperMessage.create({
+          identityKey: ourIdentityKey.pubKey,
+          registrationId: await this.storage.getOurRegistrationId(),
+          baseKey: session.pendingPreKey.baseKey,
+          signedPreKeyId: session.pendingPreKey.signedKeyId,
+          message: result,
         });
-    }
-
-    async decryptWithSessions(data, sessions) {
-        // Iterate through the sessions, attempting to decrypt using each one.
-        // Stop and return the result if we get a valid result.
-        if (!sessions.length) {
-            throw new errors.SessionError("No sessions available");
-        }   
-        const errs = [];
-        for (const session of sessions) {
-            let plaintext; 
-            try {
-                plaintext = await this.doDecryptWhisperMessage(data, session);
-                session.indexInfo.used = Date.now();
-                return {
-                    session,
-                    plaintext
-                };
-            } catch(e) {
-                errs.push(e);
-            }
-        }
-        console.error("Failed to decrypt message with any known session...");
-        for (const e of errs) {
-            console.error("Session error:" + e, e.stack);
+        if (session.pendingPreKey.preKeyId) {
+          preKeyMsg.preKeyId = session.pendingPreKey.preKeyId;
         }
-        throw new errors.SessionError("No matching sessions found for message");
-    }
+        body = Buffer.concat([
+          Buffer.from([this._encodeTupleByte(VERSION, VERSION)]),
+          Buffer.from(
+            protobufs.PreKeyWhisperMessage.encode(preKeyMsg).finish()
+          ),
+        ]);
+      } else {
+        type = 1; // normal
+        body = result;
+      }
+      return {
+        type,
+        body,
+        registrationId: session.registrationId,
+      };
+    });
+  }
 
-    async decryptWhisperMessage(data) {
-        assertBuffer(data);
-        return await this.queueJob(async () => {
-            const record = await this.getRecord();
-            if (!record) {
-                throw new errors.SessionError("No session record");
-            }
-            const result = await this.decryptWithSessions(data, record.getSessions());
-            const remoteIdentityKey = result.session.indexInfo.remoteIdentityKey;
-            if (!await this.storage.isTrustedIdentity(this.addr.id, remoteIdentityKey)) {
-                throw new errors.UntrustedIdentityKeyError(this.addr.id, remoteIdentityKey);
-            }   
-            if (record.isClosed(result.session)) {
-                // It's possible for this to happen when processing a backlog of messages.
-                // The message was, hopefully, just sent back in a time when this session
-                // was the most current.  Simply make a note of it and continue.  If our
-                // actual open session is for reason invalid, that must be handled via
-                // a full SessionError response.
-                console.warn("Decrypted message with closed session.");
-            }
-            await this.storeRecord(record);
-            return result.plaintext;
-        });
+  async decryptWithSessions(data, sessions) {
+    // Iterate through the sessions, attempting to decrypt using each one.
+    // Stop and return the result if we get a valid result.
+    if (!sessions.length) {
+      throw new errors.SessionError("No sessions available");
     }
-
-    async decryptPreKeyWhisperMessage(data) {
-        assertBuffer(data);
-        const versions = this._decodeTupleByte(data[0]);
-        if (versions[1] > 3 || versions[0] < 3) {  // min version > 3 or max version < 3
-            throw new Error("Incompatible version number on PreKeyWhisperMessage");
-        }
-        return await this.queueJob(async () => {
-            let record = await this.getRecord();
-            const preKeyProto = protobufs.PreKeyWhisperMessage.decode(data.slice(1));
-            if (!record) {
-                if (preKeyProto.registrationId == null) {
-                    throw new Error("No registrationId");
-                }
-                record = new SessionRecord();
-            }
-            const builder = new SessionBuilder(this.storage, this.addr);
-            const preKeyId = await builder.initIncoming(record, preKeyProto);
-            const session = record.getSession(preKeyProto.baseKey);
-            const plaintext = await this.doDecryptWhisperMessage(preKeyProto.message, session);
-            await this.storeRecord(record);
-            if (preKeyId) {
-                await this.storage.removePreKey(preKeyId);
-            }
-            return plaintext;
-        });
+    const errs = [];
+    for (const session of sessions) {
+      let plaintext;
+      try {
+        plaintext = await this.doDecryptWhisperMessage(data, session);
+        session.indexInfo.used = Date.now();
+        return {
+          session,
+          plaintext,
+        };
+      } catch (e) {
+        errs.push(e);
+      }
     }
+    throw new errors.SessionError("No matching sessions found for message");
+  }
 
-    async doDecryptWhisperMessage(messageBuffer, session) {
-        assertBuffer(messageBuffer);
-        if (!session) {
-            throw new TypeError("session required");
-        }
-        const versions = this._decodeTupleByte(messageBuffer[0]);
-        if (versions[1] > 3 || versions[0] < 3) {  // min version > 3 or max version < 3
-            throw new Error("Incompatible version number on WhisperMessage");
-        }
-        const messageProto = messageBuffer.slice(1, -8);
-        const message = protobufs.WhisperMessage.decode(messageProto);
-        this.maybeStepRatchet(session, message.ephemeralKey, message.previousCounter);
-        const chain = session.getChain(message.ephemeralKey);
-        if (chain.chainType === ChainType.SENDING) {
-            throw new Error("Tried to decrypt on a sending chain");
-        }
-        this.fillMessageKeys(chain, message.counter);
-        if (!chain.messageKeys.hasOwnProperty(message.counter)) {
-            // Most likely the message was already decrypted and we are trying to process
-            // twice.  This can happen if the user restarts before the server gets an ACK.
-            throw new errors.MessageCounterError('Key used already or never filled');
-        }
-        const messageKey = chain.messageKeys[message.counter];
-        delete chain.messageKeys[message.counter];
-        const keys = crypto.deriveSecrets(messageKey, Buffer.alloc(32),
-                                          Buffer.from("WhisperMessageKeys"));
-        const ourIdentityKey = await this.storage.getOurIdentity();
-        const macInput = Buffer.alloc(messageProto.byteLength + (33 * 2) + 1);
-        macInput.set(session.indexInfo.remoteIdentityKey);
-        macInput.set(ourIdentityKey.pubKey, 33);
-        macInput[33 * 2] = this._encodeTupleByte(VERSION, VERSION);
-        macInput.set(messageProto, (33 * 2) + 1);
-        // This is where we most likely fail if the session is not a match.
-        // Don't misinterpret this as corruption.
-        crypto.verifyMAC(macInput, keys[1], messageBuffer.slice(-8), 8);
-        const plaintext = crypto.decrypt(keys[0], message.ciphertext, keys[2].slice(0, 16));
-        delete session.pendingPreKey;
-        return plaintext;
-    }
+  async decryptWhisperMessage(data) {
+    assertBuffer(data);
+    return await this.queueJob(async () => {
+      const record = await this.getRecord();
+      if (!record) {
+        throw new errors.SessionError("No session record");
+      }
+      const result = await this.decryptWithSessions(data, record.getSessions());
+      const remoteIdentityKey = result.session.indexInfo.remoteIdentityKey;
+      if (
+        !(await this.storage.isTrustedIdentity(this.addr.id, remoteIdentityKey))
+      ) {
+        throw new errors.UntrustedIdentityKeyError(
+          this.addr.id,
+          remoteIdentityKey
+        );
+      }
+      if (record.isClosed(result.session)) {
+        // It's possible for this to happen when processing a backlog of messages.
+        // The message was, hopefully, just sent back in a time when this session
+        // was the most current.  Simply make a note of it and continue.  If our
+        // actual open session is for reason invalid, that must be handled via
+        // a full SessionError response.
+      }
+      await this.storeRecord(record);
+      return result.plaintext;
+    });
+  }
 
-    fillMessageKeys(chain, counter) {
-        if (chain.chainKey.counter >= counter) {
-            return;
-        }
-        if (counter - chain.chainKey.counter > 2000) {
-            throw new errors.SessionError('Over 2000 messages into the future!');
-        }
-        if (chain.chainKey.key === undefined) {
-            throw new errors.SessionError('Chain closed');
-        }
-        const key = chain.chainKey.key;
-        chain.messageKeys[chain.chainKey.counter + 1] = crypto.calculateMAC(key, Buffer.from([1]));
-        chain.chainKey.key = crypto.calculateMAC(key, Buffer.from([2]));
-        chain.chainKey.counter += 1;
-        return this.fillMessageKeys(chain, counter);
+  async decryptPreKeyWhisperMessage(data) {
+    assertBuffer(data);
+    const versions = this._decodeTupleByte(data[0]);
+    if (versions[1] > 3 || versions[0] < 3) {
+      // min version > 3 or max version < 3
+      throw new Error("Incompatible version number on PreKeyWhisperMessage");
     }
-
-    maybeStepRatchet(session, remoteKey, previousCounter) {
-        if (session.getChain(remoteKey)) {
-            return;
-        }
-        const ratchet = session.currentRatchet;
-        let previousRatchet = session.getChain(ratchet.lastRemoteEphemeralKey);
-        if (previousRatchet) {
-            this.fillMessageKeys(previousRatchet, previousCounter);
-            delete previousRatchet.chainKey.key;  // Close
+    return await this.queueJob(async () => {
+      let record = await this.getRecord();
+      const preKeyProto = protobufs.PreKeyWhisperMessage.decode(data.slice(1));
+      if (!record) {
+        if (preKeyProto.registrationId == null) {
+          throw new Error("No registrationId");
         }
-        this.calculateRatchet(session, remoteKey, false);
-        // Now swap the ephemeral key and calculate the new sending chain
-        const prevCounter = session.getChain(ratchet.ephemeralKeyPair.pubKey);
-        if (prevCounter) {
-            ratchet.previousCounter = prevCounter.chainKey.counter;
-            session.deleteChain(ratchet.ephemeralKeyPair.pubKey);
-        }
-        ratchet.ephemeralKeyPair = curve.generateKeyPair();
-        this.calculateRatchet(session, remoteKey, true);
-        ratchet.lastRemoteEphemeralKey = remoteKey;
-    }
+        record = new SessionRecord();
+      }
+      const builder = new SessionBuilder(this.storage, this.addr);
+      const preKeyId = await builder.initIncoming(record, preKeyProto);
+      const session = record.getSession(preKeyProto.baseKey);
+      const plaintext = await this.doDecryptWhisperMessage(
+        preKeyProto.message,
+        session
+      );
+      await this.storeRecord(record);
+      if (preKeyId) {
+        await this.storage.removePreKey(preKeyId);
+      }
+      return plaintext;
+    });
+  }
 
-    calculateRatchet(session, remoteKey, sending) {
-        let ratchet = session.currentRatchet;
-        const sharedSecret = curve.calculateAgreement(remoteKey, ratchet.ephemeralKeyPair.privKey);
-        const masterKey = crypto.deriveSecrets(sharedSecret, ratchet.rootKey,
-                                               Buffer.from("WhisperRatchet"), /*chunks*/ 2);
-        const chainKey = sending ? ratchet.ephemeralKeyPair.pubKey : remoteKey;
-        session.addChain(chainKey, {
-            messageKeys: {},
-            chainKey: {
-                counter: -1,
-                key: masterKey[1]
-            },
-            chainType: sending ? ChainType.SENDING : ChainType.RECEIVING
-        });
-        ratchet.rootKey = masterKey[0];
+  async doDecryptWhisperMessage(messageBuffer, session) {
+    assertBuffer(messageBuffer);
+    if (!session) {
+      throw new TypeError("session required");
+    }
+    const versions = this._decodeTupleByte(messageBuffer[0]);
+    if (versions[1] > 3 || versions[0] < 3) {
+      // min version > 3 or max version < 3
+      throw new Error("Incompatible version number on WhisperMessage");
+    }
+    const messageProto = messageBuffer.slice(1, -8);
+    const message = protobufs.WhisperMessage.decode(messageProto);
+    this.maybeStepRatchet(
+      session,
+      message.ephemeralKey,
+      message.previousCounter
+    );
+    const chain = session.getChain(message.ephemeralKey);
+    if (chain.chainType === ChainType.SENDING) {
+      throw new Error("Tried to decrypt on a sending chain");
     }
+    this.fillMessageKeys(chain, message.counter);
+    if (!chain.messageKeys.hasOwnProperty(message.counter)) {
+      // Most likely the message was already decrypted and we are trying to process
+      // twice.  This can happen if the user restarts before the server gets an ACK.
+      throw new errors.MessageCounterError("Key used already or never filled");
+    }
+    const messageKey = chain.messageKeys[message.counter];
+    delete chain.messageKeys[message.counter];
+    const keys = crypto.deriveSecrets(
+      messageKey,
+      Buffer.alloc(32),
+      Buffer.from("WhisperMessageKeys")
+    );
+    const ourIdentityKey = await this.storage.getOurIdentity();
+    const macInput = Buffer.alloc(messageProto.byteLength + 33 * 2 + 1);
+    macInput.set(session.indexInfo.remoteIdentityKey);
+    macInput.set(ourIdentityKey.pubKey, 33);
+    macInput[33 * 2] = this._encodeTupleByte(VERSION, VERSION);
+    macInput.set(messageProto, 33 * 2 + 1);
+    // This is where we most likely fail if the session is not a match.
+    // Don't misinterpret this as corruption.
+    crypto.verifyMAC(macInput, keys[1], messageBuffer.slice(-8), 8);
+    const plaintext = crypto.decrypt(
+      keys[0],
+      message.ciphertext,
+      keys[2].slice(0, 16)
+    );
+    delete session.pendingPreKey;
+    return plaintext;
+  }
 
-    async hasOpenSession() {
-        return await this.queueJob(async () => {
-            const record = await this.getRecord();
-            if (!record) {
-                return false;
-            }
-            return record.haveOpenSession();
-        });
+  fillMessageKeys(chain, counter) {
+    if (chain.chainKey.counter >= counter) {
+      return;
+    }
+    if (counter - chain.chainKey.counter > 2000) {
+      throw new errors.SessionError("Over 2000 messages into the future!");
     }
+    if (chain.chainKey.key === undefined) {
+      throw new errors.SessionError("Chain closed");
+    }
+    const key = chain.chainKey.key;
+    chain.messageKeys[chain.chainKey.counter + 1] = crypto.calculateMAC(
+      key,
+      Buffer.from([1])
+    );
+    chain.chainKey.key = crypto.calculateMAC(key, Buffer.from([2]));
+    chain.chainKey.counter += 1;
+    return this.fillMessageKeys(chain, counter);
+  }
 
-    async closeOpenSession() {
-        return await this.queueJob(async () => {
-            const record = await this.getRecord();
-            if (record) {
-                const openSession = record.getOpenSession();
-                if (openSession) {
-                    record.closeSession(openSession);
-                    await this.storeRecord(record);
-                }
-            }
-        });
+  maybeStepRatchet(session, remoteKey, previousCounter) {
+    if (session.getChain(remoteKey)) {
+      return;
+    }
+    const ratchet = session.currentRatchet;
+    let previousRatchet = session.getChain(ratchet.lastRemoteEphemeralKey);
+    if (previousRatchet) {
+      this.fillMessageKeys(previousRatchet, previousCounter);
+      delete previousRatchet.chainKey.key; // Close
     }
+    this.calculateRatchet(session, remoteKey, false);
+    // Now swap the ephemeral key and calculate the new sending chain
+    const prevCounter = session.getChain(ratchet.ephemeralKeyPair.pubKey);
+    if (prevCounter) {
+      ratchet.previousCounter = prevCounter.chainKey.counter;
+      session.deleteChain(ratchet.ephemeralKeyPair.pubKey);
+    }
+    ratchet.ephemeralKeyPair = curve.generateKeyPair();
+    this.calculateRatchet(session, remoteKey, true);
+    ratchet.lastRemoteEphemeralKey = remoteKey;
+  }
+
+  calculateRatchet(session, remoteKey, sending) {
+    let ratchet = session.currentRatchet;
+    const sharedSecret = curve.calculateAgreement(
+      remoteKey,
+      ratchet.ephemeralKeyPair.privKey
+    );
+    const masterKey = crypto.deriveSecrets(
+      sharedSecret,
+      ratchet.rootKey,
+      Buffer.from("WhisperRatchet"),
+      /*chunks*/ 2
+    );
+    const chainKey = sending ? ratchet.ephemeralKeyPair.pubKey : remoteKey;
+    session.addChain(chainKey, {
+      messageKeys: {},
+      chainKey: {
+        counter: -1,
+        key: masterKey[1],
+      },
+      chainType: sending ? ChainType.SENDING : ChainType.RECEIVING,
+    });
+    ratchet.rootKey = masterKey[0];
+  }
+
+  async hasOpenSession() {
+    return await this.queueJob(async () => {
+      const record = await this.getRecord();
+      if (!record) {
+        return false;
+      }
+      return record.haveOpenSession();
+    });
+  }
+
+  async closeOpenSession() {
+    return await this.queueJob(async () => {
+      const record = await this.getRecord();
+      if (record) {
+        const openSession = record.getOpenSession();
+        if (openSession) {
+          record.closeSession(openSession);
+          await this.storeRecord(record);
+        }
+      }
+    });
+  }
 }
 
 module.exports = SessionCipher;
diff --git a/src/session_record.js b/src/session_record.js
index 7626a3927fadcdf7f66b3d0c9cf8c63d33da579b..5047c2d8958eb26bf3fe74c75dbaee0eac8bcce0 100644
--- a/src/session_record.js
+++ b/src/session_record.js
@@ -1,316 +1,320 @@
 // vim: ts=4:sw=4
 
-const BaseKeyType = require('./base_key_type');
+const BaseKeyType = require("./base_key_type");
 
 const CLOSED_SESSIONS_MAX = 40;
-const SESSION_RECORD_VERSION = 'v1';
+const SESSION_RECORD_VERSION = "v1";
 
 function assertBuffer(value) {
-    if (!Buffer.isBuffer(value)) {
-        throw new TypeError("Buffer required");
-    }
+  if (!Buffer.isBuffer(value)) {
+    throw new TypeError("Buffer required");
+  }
 }
 
-
 class SessionEntry {
-
-    constructor() {
-        this._chains = {};
+  constructor() {
+    this._chains = {};
+  }
+
+  toString() {
+    const baseKey =
+      this.indexInfo &&
+      this.indexInfo.baseKey &&
+      this.indexInfo.baseKey.toString("base64");
+    return `<SessionEntry [baseKey=${baseKey}]>`;
+  }
+
+  inspect() {
+    return this.toString();
+  }
+
+  addChain(key, value) {
+    assertBuffer(key);
+    const id = key.toString("base64");
+    if (this._chains.hasOwnProperty(id)) {
+      throw new Error("Overwrite attempt");
     }
-
-    toString() {
-        const baseKey = this.indexInfo && this.indexInfo.baseKey &&
-            this.indexInfo.baseKey.toString('base64');
-        return `<SessionEntry [baseKey=${baseKey}]>`;
+    this._chains[id] = value;
+  }
+
+  getChain(key) {
+    assertBuffer(key);
+    return this._chains[key.toString("base64")];
+  }
+
+  deleteChain(key) {
+    assertBuffer(key);
+    const id = key.toString("base64");
+    if (!this._chains.hasOwnProperty(id)) {
+      throw new ReferenceError("Not Found");
     }
+    delete this._chains[id];
+  }
 
-    inspect() {
-        return this.toString();
-    }
-
-    addChain(key, value) {
-        assertBuffer(key);
-        const id = key.toString('base64');
-        if (this._chains.hasOwnProperty(id)) {
-            throw new Error("Overwrite attempt");
-        }
-        this._chains[id] = value;
+  *chains() {
+    for (const [k, v] of Object.entries(this._chains)) {
+      yield [Buffer.from(k, "base64"), v];
     }
-
-    getChain(key) {
-        assertBuffer(key);
-        return this._chains[key.toString('base64')];
+  }
+
+  serialize() {
+    const data = {
+      registrationId: this.registrationId,
+      currentRatchet: {
+        ephemeralKeyPair: {
+          pubKey:
+            this.currentRatchet.ephemeralKeyPair.pubKey.toString("base64"),
+          privKey:
+            this.currentRatchet.ephemeralKeyPair.privKey.toString("base64"),
+        },
+        lastRemoteEphemeralKey:
+          this.currentRatchet.lastRemoteEphemeralKey.toString("base64"),
+        previousCounter: this.currentRatchet.previousCounter,
+        rootKey: this.currentRatchet.rootKey.toString("base64"),
+      },
+      indexInfo: {
+        baseKey: this.indexInfo.baseKey.toString("base64"),
+        baseKeyType: this.indexInfo.baseKeyType,
+        closed: this.indexInfo.closed,
+        used: this.indexInfo.used,
+        created: this.indexInfo.created,
+        remoteIdentityKey: this.indexInfo.remoteIdentityKey.toString("base64"),
+      },
+      _chains: this._serialize_chains(this._chains),
+    };
+    if (this.pendingPreKey) {
+      data.pendingPreKey = Object.assign({}, this.pendingPreKey);
+      data.pendingPreKey.baseKey =
+        this.pendingPreKey.baseKey.toString("base64");
     }
-
-    deleteChain(key) {
-        assertBuffer(key);
-        const id = key.toString('base64');
-        if (!this._chains.hasOwnProperty(id)) {
-            throw new ReferenceError("Not Found");
-        }
-        delete this._chains[id];
+    return data;
+  }
+
+  static deserialize(data) {
+    const obj = new this();
+    obj.registrationId = data.registrationId;
+    obj.currentRatchet = {
+      ephemeralKeyPair: {
+        pubKey: Buffer.from(
+          data.currentRatchet.ephemeralKeyPair.pubKey,
+          "base64"
+        ),
+        privKey: Buffer.from(
+          data.currentRatchet.ephemeralKeyPair.privKey,
+          "base64"
+        ),
+      },
+      lastRemoteEphemeralKey: Buffer.from(
+        data.currentRatchet.lastRemoteEphemeralKey,
+        "base64"
+      ),
+      previousCounter: data.currentRatchet.previousCounter,
+      rootKey: Buffer.from(data.currentRatchet.rootKey, "base64"),
+    };
+    obj.indexInfo = {
+      baseKey: Buffer.from(data.indexInfo.baseKey, "base64"),
+      baseKeyType: data.indexInfo.baseKeyType,
+      closed: data.indexInfo.closed,
+      used: data.indexInfo.used,
+      created: data.indexInfo.created,
+      remoteIdentityKey: Buffer.from(
+        data.indexInfo.remoteIdentityKey,
+        "base64"
+      ),
+    };
+    obj._chains = this._deserialize_chains(data._chains);
+    if (data.pendingPreKey) {
+      obj.pendingPreKey = Object.assign({}, data.pendingPreKey);
+      obj.pendingPreKey.baseKey = Buffer.from(
+        data.pendingPreKey.baseKey,
+        "base64"
+      );
     }
-
-    *chains() {
-        for (const [k, v] of Object.entries(this._chains)) {
-            yield [Buffer.from(k, 'base64'), v];
-        }
+    return obj;
+  }
+
+  _serialize_chains(chains) {
+    const r = {};
+    for (const key of Object.keys(chains)) {
+      const c = chains[key];
+      const messageKeys = {};
+      for (const [idx, key] of Object.entries(c.messageKeys)) {
+        messageKeys[idx] = key.toString("base64");
+      }
+      r[key] = {
+        chainKey: {
+          counter: c.chainKey.counter,
+          key: c.chainKey.key && c.chainKey.key.toString("base64"),
+        },
+        chainType: c.chainType,
+        messageKeys: messageKeys,
+      };
     }
-
-    serialize() {
-        const data = {
-            registrationId: this.registrationId,
-            currentRatchet: {
-                ephemeralKeyPair: {
-                    pubKey: this.currentRatchet.ephemeralKeyPair.pubKey.toString('base64'),
-                    privKey: this.currentRatchet.ephemeralKeyPair.privKey.toString('base64')
-                },
-                lastRemoteEphemeralKey: this.currentRatchet.lastRemoteEphemeralKey.toString('base64'),
-                previousCounter: this.currentRatchet.previousCounter,
-                rootKey: this.currentRatchet.rootKey.toString('base64')
-            },
-            indexInfo: {
-                baseKey: this.indexInfo.baseKey.toString('base64'),
-                baseKeyType: this.indexInfo.baseKeyType,
-                closed: this.indexInfo.closed,
-                used: this.indexInfo.used,
-                created: this.indexInfo.created,
-                remoteIdentityKey: this.indexInfo.remoteIdentityKey.toString('base64')
-            },
-            _chains: this._serialize_chains(this._chains)
-        };
-        if (this.pendingPreKey) {
-            data.pendingPreKey = Object.assign({}, this.pendingPreKey);
-            data.pendingPreKey.baseKey = this.pendingPreKey.baseKey.toString('base64');
-        }
-        return data;
+    return r;
+  }
+
+  static _deserialize_chains(chains_data) {
+    const r = {};
+    for (const key of Object.keys(chains_data)) {
+      const c = chains_data[key];
+      const messageKeys = {};
+      for (const [idx, key] of Object.entries(c.messageKeys)) {
+        messageKeys[idx] = Buffer.from(key, "base64");
+      }
+      r[key] = {
+        chainKey: {
+          counter: c.chainKey.counter,
+          key: c.chainKey.key && Buffer.from(c.chainKey.key, "base64"),
+        },
+        chainType: c.chainType,
+        messageKeys: messageKeys,
+      };
     }
-
-    static deserialize(data) {
-        const obj = new this();
-        obj.registrationId = data.registrationId;
-        obj.currentRatchet = {
-            ephemeralKeyPair: {
-                pubKey: Buffer.from(data.currentRatchet.ephemeralKeyPair.pubKey, 'base64'),
-                privKey: Buffer.from(data.currentRatchet.ephemeralKeyPair.privKey, 'base64')
-            },
-            lastRemoteEphemeralKey: Buffer.from(data.currentRatchet.lastRemoteEphemeralKey, 'base64'),
-            previousCounter: data.currentRatchet.previousCounter,
-            rootKey: Buffer.from(data.currentRatchet.rootKey, 'base64')
-        };
-        obj.indexInfo = {
-            baseKey: Buffer.from(data.indexInfo.baseKey, 'base64'),
-            baseKeyType: data.indexInfo.baseKeyType,
-            closed: data.indexInfo.closed,
-            used: data.indexInfo.used,
-            created: data.indexInfo.created,
-            remoteIdentityKey: Buffer.from(data.indexInfo.remoteIdentityKey, 'base64')
-        };
-        obj._chains = this._deserialize_chains(data._chains);
-        if (data.pendingPreKey) {
-            obj.pendingPreKey = Object.assign({}, data.pendingPreKey);
-            obj.pendingPreKey.baseKey = Buffer.from(data.pendingPreKey.baseKey, 'base64');
-        }
-        return obj;
-    }
-
-    _serialize_chains(chains) {
-        const r = {};
-        for (const key of Object.keys(chains)) {
-            const c = chains[key];
-            const messageKeys = {};
-            for (const [idx, key] of Object.entries(c.messageKeys)) {
-                messageKeys[idx] = key.toString('base64');
-            }
-            r[key] = {
-                chainKey: {
-                    counter: c.chainKey.counter,
-                    key: c.chainKey.key && c.chainKey.key.toString('base64')
-                },
-                chainType: c.chainType,
-                messageKeys: messageKeys
-            };
-        }
-        return r;
-    }
-
-    static _deserialize_chains(chains_data) {
-        const r = {};
-        for (const key of Object.keys(chains_data)) {
-            const c = chains_data[key];
-            const messageKeys = {};
-            for (const [idx, key] of Object.entries(c.messageKeys)) {
-                messageKeys[idx] = Buffer.from(key, 'base64');
-            }
-            r[key] = {
-                chainKey: {
-                    counter: c.chainKey.counter,
-                    key: c.chainKey.key && Buffer.from(c.chainKey.key, 'base64')
-                },
-                chainType: c.chainType,
-                messageKeys: messageKeys
-            };
-        }
-        return r;
-    }
-
+    return r;
+  }
 }
 
-
-const migrations = [{
-    version: 'v1',
+const migrations = [
+  {
+    version: "v1",
     migrate: function migrateV1(data) {
-        const sessions = data._sessions;
-        if (data.registrationId) {
-            for (const key in sessions) {
-                if (!sessions[key].registrationId) {
-                    sessions[key].registrationId = data.registrationId;
-                }
-            }
-        } else {
-            for (const key in sessions) {
-                if (sessions[key].indexInfo.closed === -1) {
-                    console.error('V1 session storage migration error: registrationId',
-                                  data.registrationId, 'for open session version',
-                                  data.version);
-                }
-            }
+      const sessions = data._sessions;
+      if (data.registrationId) {
+        for (const key in sessions) {
+          if (!sessions[key].registrationId) {
+            sessions[key].registrationId = data.registrationId;
+          }
         }
-    }
-}];
-
+      }
+    },
+  },
+];
 
 class SessionRecord {
-
-    static createEntry() {
-        return new SessionEntry();
+  static createEntry() {
+    return new SessionEntry();
+  }
+
+  static migrate(data) {
+    let run = data.version === undefined;
+    for (let i = 0; i < migrations.length; ++i) {
+      if (run) {
+        migrations[i].migrate(data);
+      } else if (migrations[i].version === data.version) {
+        run = true;
+      }
     }
-
-    static migrate(data) {
-        let run = (data.version === undefined);
-        for (let i = 0; i < migrations.length; ++i) {
-            if (run) {
-                console.info("Migrating session to:", migrations[i].version);
-                migrations[i].migrate(data);
-            } else if (migrations[i].version === data.version) {
-                run = true;
-            }
-        }
-        if (!run) {
-            throw new Error("Error migrating SessionRecord");
-        }
+    if (!run) {
+      throw new Error("Error migrating SessionRecord");
     }
+  }
 
-    static deserialize(data) {
-        if (data.version !== SESSION_RECORD_VERSION) {
-            this.migrate(data);
-        }
-        const obj = new this();
-        if (data._sessions) {
-            for (const [key, entry] of Object.entries(data._sessions)) {
-                obj.sessions[key] = SessionEntry.deserialize(entry);
-            }
-        }
-        return obj;
+  static deserialize(data) {
+    if (data.version !== SESSION_RECORD_VERSION) {
+      this.migrate(data);
     }
-
-    constructor() {
-        this.sessions = {};
-        this.version = SESSION_RECORD_VERSION;
+    const obj = new this();
+    if (data._sessions) {
+      for (const [key, entry] of Object.entries(data._sessions)) {
+        obj.sessions[key] = SessionEntry.deserialize(entry);
+      }
     }
-
-    serialize() {
-        const _sessions = {};
-        for (const [key, entry] of Object.entries(this.sessions)) {
-            _sessions[key] = entry.serialize();
-        }
-        return {
-            _sessions,
-            version: this.version
-        };
+    return obj;
+  }
+
+  constructor() {
+    this.sessions = {};
+    this.version = SESSION_RECORD_VERSION;
+  }
+
+  serialize() {
+    const _sessions = {};
+    for (const [key, entry] of Object.entries(this.sessions)) {
+      _sessions[key] = entry.serialize();
     }
-
-    haveOpenSession() {
-        const openSession = this.getOpenSession();
-        return (!!openSession && typeof openSession.registrationId === 'number');
+    return {
+      _sessions,
+      version: this.version,
+    };
+  }
+
+  haveOpenSession() {
+    const openSession = this.getOpenSession();
+    return !!openSession && typeof openSession.registrationId === "number";
+  }
+
+  getSession(key) {
+    assertBuffer(key);
+    const session = this.sessions[key.toString("base64")];
+    if (session && session.indexInfo.baseKeyType === BaseKeyType.OURS) {
+      throw new Error("Tried to lookup a session using our basekey");
     }
+    return session;
+  }
 
-    getSession(key) {
-        assertBuffer(key);
-        const session = this.sessions[key.toString('base64')];
-        if (session && session.indexInfo.baseKeyType === BaseKeyType.OURS) {
-            throw new Error("Tried to lookup a session using our basekey");
-        }
+  getOpenSession() {
+    for (const session of Object.values(this.sessions)) {
+      if (!this.isClosed(session)) {
         return session;
+      }
     }
-
-    getOpenSession() {
-        for (const session of Object.values(this.sessions)) {
-            if (!this.isClosed(session)) {
-                return session;
-            }
-        }
+  }
+
+  setSession(session) {
+    this.sessions[session.indexInfo.baseKey.toString("base64")] = session;
+  }
+
+  getSessions() {
+    // Return sessions ordered with most recently used first.
+    return Array.from(Object.values(this.sessions)).sort((a, b) => {
+      const aUsed = a.indexInfo.used || 0;
+      const bUsed = b.indexInfo.used || 0;
+      return aUsed === bUsed ? 0 : aUsed < bUsed ? 1 : -1;
+    });
+  }
+
+  closeSession(session) {
+    if (this.isClosed(session)) {
+      return;
     }
-
-    setSession(session) {
-        this.sessions[session.indexInfo.baseKey.toString('base64')] = session;
-    }
-
-    getSessions() {
-        // Return sessions ordered with most recently used first.
-        return Array.from(Object.values(this.sessions)).sort((a, b) => {
-            const aUsed = a.indexInfo.used || 0;
-            const bUsed = b.indexInfo.used || 0;
-            return aUsed === bUsed ? 0 : aUsed < bUsed ? 1 : -1;
-        });
-    }
-
-    closeSession(session) {
-        if (this.isClosed(session)) {
-            console.warn("Session already closed", session);
-            return;
-        }
-        console.info("Closing session:", session);
-        session.indexInfo.closed = Date.now();
-    }
-
-    openSession(session) {
-        if (!this.isClosed(session)) {
-            console.warn("Session already open");
+    session.indexInfo.closed = Date.now();
+  }
+
+  openSession(session) {
+    session.indexInfo.closed = -1;
+  }
+
+  isClosed(session) {
+    return session.indexInfo.closed !== -1;
+  }
+
+  removeOldSessions() {
+    while (Object.keys(this.sessions).length > CLOSED_SESSIONS_MAX) {
+      let oldestKey;
+      let oldestSession;
+      for (const [key, session] of Object.entries(this.sessions)) {
+        if (
+          session.indexInfo.closed !== -1 &&
+          (!oldestSession ||
+            session.indexInfo.closed < oldestSession.indexInfo.closed)
+        ) {
+          oldestKey = key;
+          oldestSession = session;
         }
-        console.info("Opening session:", session);
-        session.indexInfo.closed = -1;
+      }
+      if (oldestKey) {
+        delete this.sessions[oldestKey];
+      } else {
+        throw new Error("Corrupt sessions object");
+      }
     }
+  }
 
-    isClosed(session) {
-        return session.indexInfo.closed !== -1;
-    }
-
-    removeOldSessions() {
-        while (Object.keys(this.sessions).length > CLOSED_SESSIONS_MAX) {
-            let oldestKey;
-            let oldestSession;
-            for (const [key, session] of Object.entries(this.sessions)) {
-                if (session.indexInfo.closed !== -1 &&
-                    (!oldestSession || session.indexInfo.closed < oldestSession.indexInfo.closed)) {
-                    oldestKey = key;
-                    oldestSession = session;
-                }
-            }
-            if (oldestKey) {
-                console.info("Removing old closed session:", oldestSession);
-                delete this.sessions[oldestKey];
-            } else {
-                throw new Error('Corrupt sessions object');
-            }
-        }
-    }
-
-    deleteAllSessions() {
-        for (const key of Object.keys(this.sessions)) {
-            delete this.sessions[key];
-        }
+  deleteAllSessions() {
+    for (const key of Object.keys(this.sessions)) {
+      delete this.sessions[key];
     }
+  }
 }
 
 module.exports = SessionRecord;
